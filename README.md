# OOP_lab3

# lab3a
Цей код включає дві основні функції: merge_sort() для однопотокової версії і parallel_merge_sort() для многопотокової версії. Функція merge() служить вспомогательним інструментом для комбінування двох вже відсортованих підсписків.

У функції parallel_merge_sort(), якщо задана кількість потоків перевищує 1, функція генерує два нові потоки, кожен з яких обробляє свою половину списку, викликаючи parallel_merge_sort() рекурсивно. В іншому випадку, якщо кількість потоків рівна 1, то merge_sort() використовується для обробки відповідного підсписку.

# lab3b
Цей код ілюструє як виконувати ігровий цикл з допомогою багатопоточності в C++. У головній функції ми ініціюємо об'єкт Game, який створює і запускає три окремих потоки: один для обробки дій користувача, другий для візуалізації ігрового середовища, а третій для оновлення стану ігрових об'єктів. Кожен з цих потоків виконує цикл, у якому викликається відповідна функція об'єкта Game (HandleInput, Render або Update), а потім "засинає" на невеликий проміжок часу перед наступним циклом.

У класі Game є приватні поля для ігрових об'єктів, а також м'ютекс для безпечного управління доступом до цих об'єктів. Функції HandleInput, Render та Update модифікують і/або доступаються до цих полів, використовуючи м'ютекс для уникнення проблем, пов'язаних з гонкою.

Даний код використовує умовну змінну (cv) для інформування потоку рендерингу, коли новий кадр готовий до візуалізації. Потік рендерингу чекає на умовну змінну, доки не отримає сигнал від потоку оновлення, що новий кадр готовий.

У підсумку, код показує, як можна використовувати багатопоточність для покращення продуктивності та реакції на ігровий цикл, розподіляючи роботу між кількома потоками.